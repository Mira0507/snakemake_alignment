---
title: "STAR vs HISAT2 (Focused on Mean/Fold/FDR)"
author: "Mira Sohn" 
output:
    html_document:
        keep_md: yes
---

```{r global_options, include=FALSE}


knitr::opts_chunk$set(
    warning=FALSE,
    message=FALSE
    )


```



## Loading packages

#### - **AnnotationHub**: https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub.html

#### - **DESeq2**: http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

```{r loading_packages}

library(data.table)
library(tidyverse)
library(rmarkdown)
library(ggplot2)
library(pheatmap)
library(AnnotationHub)
library(DESeq2)
library(UpSetR)
library(ensembldb)
library(gridExtra)
library(httr) 
library(jsonlite) 

```


## Loading R config file 


```{r}

source("../config/config_paired1.R")

```


## Setting AnnotationHub



```{r annotationhub}

DB <- my.anno.db                     # Set your DB of interest
AnnotationSpecies <- my.species      # Set your species of interest
ah <- AnnotationHub(hub=getAnnotationHubOption("URL"))  # Bring annotation DB



# Filter annotation of interest
ahQuery <- query(ah, 
                 pattern=c(DB, AnnotationSpecies), 
                 ignore.case=T)      


# Select the most recent data
DBName <- mcols(ahQuery) %>%
    rownames() %>%
    tail(1)

anno.db <- ah[[DBName]] 

# Explore your EnsDb object with following accessors:
# columns(AnnpDb)
# keytypes(AnnoDb)
# keys(AnnoDb, keytype=..)
# select(AnnoDb, keys=.., columns=.., keytype=...)
AnnoKey <- keys(anno.db, keytype="TXID")
# Note: Annotation has to be done with not genome but transcripts 
AnnoDb <- select(anno.db, 
                 AnnoKey,
                 keytype="TXID",
                 columns=c("TXID", "GENEID", "GENENAME"))


# Check if your AnnoDb has been extracted and saved correctely
class(AnnoDb)
head(AnnoDb)    # The column 1 has to assign transcript (e.g. ENSEMBLTRANS)
```



## Loading count matrices 


```{r read_countmatrix}

# Import read count matrices and clean the data frame

# Assign column names that will be deleted 
trim.col <- c("Chr", "Start", "End", "Strand", "Length")

# Aligner names
Aligners <- c("HISAT2", "STAR")

# Create an empty list for storing imported and cleaned count matrices
countList <- list()

for (x in Aligners) {

    # Import the count tsv file
    df <- read.table(featurecounts.path[[x]], 
                     sep="\t", 
                     header=T) 

    # Deleted redundant columns
    df <- df[, !(colnames(df) %in% trim.col)]

    # Save the imported & cleaned count data frame
    countList[[x]] <- df

}


# Explore the output
head(countList[[1]])
head(countList[[2]])

dim(countList[[1]])
dim(countList[[2]])

```




## Metadata setting

```{r generating_metadata}

# Import your sample table 
SampleTable <- read.csv(sample.csv)


# Define sample names 
SampleNames <- SampleTable$sample


# Define group level
GroupLevel <- unique(SampleTable$group)

# Define contrast for DE analysis
Contrast <- c("Group", GroupLevel)

# Define group names
GroupNames <- SampleTable$group


# Create metadata
metadata <- data.frame(Sample=factor(SampleNames, levels=SampleNames),
                       Group=factor(GroupNames, levels=GroupLevel))

# Assign row names with sample names
rownames(metadata) <- SampleNames


# Explore the metadata
print(metadata)


```



## Data cleaning: sample and gene annotation


```{r count_dataframe_cleaning}



# Set a function cleaning the count data frame
clean.fn <- function(df) {

    # Convert to a data frame
    df <- as.data.frame(df)

    # Assign column names
    names(df) <- c("GENEID", SampleNames)


    return(df)
}


# Set a function to drop GENEID version
clean.annotation.fn <- function(df) {

    # Re-annotate without version specification
    df <- separate(df, "GENEID", c("GENEID", "Version"))

    # Remove version column
    df <- df[, colnames(df) != "Version"]

    return(df)
}

# Move GENEID to a column
for (x in Aligners) {

    countList[[x]] <- clean.fn(countList[[x]])

}


# Remove version of GENEID and duplicated rows in STAR & HISAT2 count tables
for (x in Aligners) {

    countList[[x]] <- clean.annotation.fn(countList[[x]]) %>% 

        distinct()

}



# Explore the cleaned count data frames 
head(countList[[1]])
head(countList[[2]])
dim(countList[[1]])
dim(countList[[2]])
sum(duplicated(countList[[1]]))
sum(duplicated(countList[[2]]))



```



## Plotting sequencing depth 

#### Number of total counts per sample

```{r library_size}

# Set a function generating a data frame with sequencing depth
seq.depth.fn <- function(df, aligner) {

    seqdf <- as.data.frame(colSums(df[, SampleNames])) %>% 
        rownames_to_column (var="Sample") %>% 
        mutate(Aligner=aligner)

    names(seqdf) <- c("Sample", "Count", "Aligner")

    return(seqdf)
}

# Set a function for a bar plot comparing values
comparing.barplot.fn <- function(df, yval, title, ytitle) {

    ggplot(df, 
       aes(x=Sample, y=yval, group=Aligner, fill=Aligner)) +
    geom_bar(stat="identity", position="dodge") +
    theme_bw() +
    theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) +
    ggtitle(title) + 
    ylab(ytitle)

}




# Initialize the seq depth data frame with the first aligner
seq.depth.df <- seq.depth.fn(countList[[1]], Aligners[1])

# Extend the seq depth data frame with the rest of aligners
for (x in Aligners) {

    if (x %in% Aligners[2:length(Aligners)]) {

        seq.depth.df <- rbind(seq.depth.df, 
                              seq.depth.fn(countList[[x]], x))
    }
}

# Explore how the data frame 
print(seq.depth.df)
summary(seq.depth.df)

# Convert character vectors to factors
seq.depth.df$Sample <- factor(seq.depth.df$Sample, 
                              levels=SampleNames)
seq.depth.df$Aligner <- factor(seq.depth.df$Aligner, 
                               levels=Aligners)

# Create a plot presenting sequencing depth
comparing.barplot.fn(seq.depth.df, 
                     seq.depth.df$Count, 
                     "Sequencing Depth by Sample and Aligner", 
                     "Count")

```

## Generating DESeq2 objects

#### - **vst()** was run to perform variance stabilizing transformation instead of rlog() which takes longer time with similar characteristics. 

#### - The **vsd** object created by vst() is used for not DE analysis but QC.

#### - References: [**DESeq2 doc "Transcript abundance files"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#tximport), [**DESeq2 doc "Variance stabilizing transformation"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#variance-stabilizing-transformation)

```{r generating_deseq2_objects}

# Initialize new lists for storing dds objects
ddsList <- list()

# Initialize new lists for storing vsd objects
vsdList <- list()


for (x in Aligners) {

    # Create a count matrix from the count data frame 
    m <- countList[[x]][, colnames(countList[[x]]) != "GENEID"] %>% 
        as.matrix()

    # Assigne row names
    rownames(m) <- countList[[x]]$GENEID

    # Generate a DESeq2 object
    ddsList[[x]] <- DESeqDataSetFromMatrix(m, 
                                           colData=metadata, 
                                           design=~Group) 

    # Conduct vst
    vsdList[[x]] <- varianceStabilizingTransformation(ddsList[[x]], 
                                                      blind=TRUE) 
}

# Explore generated objects
summary(ddsList)
summary(vsdList)


```


## Estimating size factors

#### - black dashed line: size factor = 1

#### - Reference: [**DESeq2 doc "Sample-/gene-dependent normalization factors"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#log-fold-change-shrinkage-for-visualization-and-ranking)


```{r size_factors}

# Calculate and add size factors to the DEseq object
for (x in Aligners) {

    ddsList[[x]] <- estimateSizeFactors(ddsList[[x]])

}

# Set a function summarizing size factors by aligner to a data frame
sfactor.fn <- function(df, aligner) {

    sizefactor <- as.data.frame(round(sizeFactors(df), 3)) %>%
        rownames_to_column(var="Sample") %>%
        mutate(Aligner=aligner)

    names(sizefactor) <- c("Sample", "Size_Factor", "Aligner")

    return(sizefactor)

}

# Initialize a data frame with the first aligner 
size.factor.df <- sfactor.fn(ddsList[[1]], Aligners[1])


for (x in Aligners) {

    if (x != Aligners[1]) {

        size.factor.df <- rbind(size.factor.df, 
                                sfactor.fn(ddsList[[x]], x))
    }
}


# Explore the data frame
print(size.factor.df)

# Convert character vectors to factors
size.factor.df$Sample <- factor(size.factor.df$Sample, 
                              levels=SampleNames)
size.factor.df$Aligner <- factor(size.factor.df$Aligner, 
                               levels=Aligners)

# Plot calculated size factors
comparing.barplot.fn(size.factor.df, 
                     size.factor.df$Size_Factor,  
                     "Size Factors by Aligner and Sample", 
                     "Size Factor") + geom_hline(yintercept=1, linetype="dashed", color="black", size=1)

```


## Estimating dispersion and Wald test

#### - **Dispersion** is calculated as a **measure of variation** instead of variance since variance gets larger when gene expression gets higher. 

#### - **Wald test** is the default setting of DESeq2 which tests null hypothesis between **two groups**. You should use **Likelihood ratio test (LRT)** when comparing **more than two groups**. 

#### - References: [**Harvard Chan Bioinformatics Core workshop I**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/05b_wald_test_results.md), [**Harvard Chan Bioinformatics Core workshop II**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/05a_hypothesis_testing.md), [**Harvard Chan Bioinformatics Core workshop III**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/04b_DGE_DESeq2_analysis.md), [**DESeq2 "Wald test indivisual steps**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#wald-test-individual-steps), [**DESeq2 doc "Likelihood ratio test"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#likelihood-ratio-test)

```{r dispersion_waldtest}

for (x in Aligners) {

    # Dispersion
    ddsList[[x]] <- estimateDispersions(ddsList[[x]])
    
    # Wald test
    ddsList[[x]] <- nbinomWaldTest(ddsList[[x]])

}


# Explore generated data in the dds object 
ddsList[[1]]

```

## Sample QC: Principal Component Analysis (PCA)

#### Identifies source of variation and sample outliers

#### - Reference: [**DESeq2 doc "Principal component plot of the samples"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#principal-component-plot-of-the-samples), [**DESeq2 doc "Heatmap of the sample-to-sample distances"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#heatmap-of-the-sample-to-sample-distances)

```{r QC_PCA}

# Print PCA plots 
for (x in Aligners) {

    # Vsd object
    my.vsd <- vsdList[[x]]

    # Aligner name
    my.aligner <- x

    # Print the PCA result
    print(plotPCA(my.vsd, 
                  intgroup=Contrast[1],
                  returnData=F) + 
          theme_bw() + 
          ggtitle(paste("PCA:", my.aligner)))

}



```

## Sample QC: Sample Correlation Heatmap

#### Identifies distance between samples & correlation in a group

```{r QC_correlation_heatmap}

# Heatmap annotation
HeatmapAnno <- metadata[, c("Sample", "Group")]

for (x in Aligners) {

    # Extract a normalized count matrix 
    vm <- assay(vsdList[[x]])

    # Generate a correlation matrix
    cm <- cor(vm)

    # Print a heatmap
    print(pheatmap(cm, 
                   annotation=HeatmapAnno,
                   main=paste("Sample Correlation Heatmap:", 
                              x)))

}


```

## Running DE analysis


```{r DE_analysis}



# Run DESeq 
for (x in Aligners) {

    ddsList[[x]] <- DESeq(ddsList[[x]])
    # Check result names 
    ResNames <- resultsNames(ddsList[[x]])
    print(ResNames)

}


```

## Creating dispersion plots


#### - Dispersion is important since estimation by DESeq2 algorithm is based on the assumption that genes with similar expression levels have similar dispersion. If an RNA-seq dataset doesn't satisfy this assumption, use other DE algorithms than DESeq2. 

#### - References: [**DESeq2 doc "Dispersion plot and fitting alternatives**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#dispersion-plot-and-fitting-alternatives), [**Harvard Chan Bioinformatics Core workshop **](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/04b_DGE_DESeq2_analysis.md)

```{r dispersion_plot}


for (x in Aligners) {

    # Assign input
    dds <- ddsList[[x]]

    # Print the dispersion plot
    print(plotDispEsts(dds, 
                       main=paste("Dispersion over Counts:", 
                                  x)))

}




# Do they fit well with the DESeq2 estimation model?

```

## Setting how to extract fold-change results

#### Change variables below

#### - The **alpha** denotes threshold of **false discovery rate (FDR)** assigned by users.

#### - In this analysis, the alpha is set to **0.1** 

```{r setting_resultcondition}



# Set the coefficients to compare 
Coef <- ResNames[-1]
print(Coef) 



# Set a function to clean a result table 
lfctable.fn <- function(df) {
    df <- df %>% 
        rownames_to_column(var="GENEID") %>%
        mutate(FDR=ifelse(padj < 0.1 & !is.na(padj), 
                                   paste("<", alpha),
                                   paste(">", alpha)))
    return(df)
}

# Set a function extracting results
extract.lfc.fn <- function(dds) {

    res <- results(dds, contrast=Contrast, alpha=alpha)

    return(lfctable.fn(as.data.frame(res)))


}

```


## Extracting log2FoldChanges

#### You can change alpha depending on your interest of FDR level

#### Shrinkage is NOT applied in this analysis





```{r DEresult_extraction}

# Initialize a list storing lfc data frames
lfcList <- list()

# Extract DE results
# The Contrast variable was defined in the previous chunk
# Extraction with no shrinkage
# alpha: FDR threshold
for (x in Aligners) {

    lfcList[[x]] <- extract.lfc.fn(ddsList[[x]]) %>% mutate(Alignment=x) 

    write.csv(lfcList[[x]], paste0("lfc_", x, ".csv"))

    print(head(lfcList[[x]]))

}

# Initialize a data frame storing total lfc results across the aligners
lfc.dataframe <- lfcList[[1]] 

for (x in Aligners[2:length(Aligners)]) {

    lfc.dataframe <- rbind(lfc.dataframe, 
                           lfcList[[x]])

}


lfc.dataframe$Alignment <- factor(lfc.dataframe$Alignment, 
                                  levels=Aligners)


```



## Exploring distribution of false discovery rate (FDR)

#### Black dashed line: FDR

```{r FDR_distribution}

# Plot distribution of FDR 
ggplot(lfc.dataframe, 
       aes(x=padj, y=..count.., color=Alignment)) + 
    geom_density(size=1) + 
    theme_bw() + 
    ggtitle("Distribution of False Discovery Rate (FDR) by Aligner") + 
    ylab("Count") +
    xlim(0.00001, 1) + 
    geom_vline(xintercept=alpha, 
               color="black", 
               size=1, linetype="dashed") + 
    scale_x_continuous(breaks=seq(0, 1, by=0.1))



```

## Presenting distribution of log2FoldChange

### Black: total genes (padj =/= NA)
### Colored: genes above or below FDR=0.1


```{r L2FC_distribution}

valid.lfc.df <- subset(lfc.dataframe, FDR == paste("<",  alpha))

ggplot(valid.lfc.df,
       aes(x=log2FoldChange,
           y=..count.., 
           color=Alignment)) +
geom_density(size=1) + 
theme_bw() + 
geom_vline(xintercept=c(-1, 1), 
           linetype="dashed", color="black", size=1) + 
ggtitle(paste0("Distribution of log2FoldChange Values by Aligner (FDR < ", alpha, ")")) +
ylab("Count") + 
xlim(-10, 10)    # Change xlim by datatype

```


## Exploring mean-difference with an MA plot

#### - Reference: [**DESeq2 doc "MA-plot"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#ma-plot)

#### - **x-axis**: expression level (baseMean)

#### - **y-axis**: fold change (log2FoldChange)

#### - **Red dashed lines**: log2FoldChange = -1 and 1 

```{r MAplot}




# Create MA plots by Aligner
ggplot(lfc.dataframe, aes(x=baseMean, y=log2FoldChange, color=FDR)) + 
        geom_point() + 
        facet_grid(~Alignment) +
        scale_x_log10() + 
        theme_bw() + 
        scale_color_manual(values=c("blue", "grey")) + 
        ggtitle(paste("MA plot")) +
        theme(strip.text.x=element_text(size=10)) +
        geom_hline(yintercept=c(mLog[1], mLog[2]), 
                   linetype="dashed", color="red", size=1) 


```

## Exploring expression profiling with normalized count data

#### - Normalized count matrices are extracted from dds objects and filtered with thresholds set at FDR and log2FoldChange

#### - The heatmaps display **z-scores** of the normalized counts

#### - In this analysis, **mLog = 1** by default (see config.R file)

#### - References: [**Harvard Chan Bioinformatics Core workshop**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/06_DGE_visualizing_results.md), [**DESeq2 doc "Heatmap of the count matrix"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#heatmap-of-the-count-matrix)

```{r expression_heatmap}

# Initialize a list 
heatmap.df.List <- list()

# Filter genes with FDR < alpha and absolute log2FoldChange > 1
for (x in Aligners) {

    # Set a logical vector filtering FDR below alpha
    is.fdr.valid <- lfcList[[x]]$FDR == paste("<", alpha)

    # Set a logical vector filtering absolute lfc above 1 
    is.lfc.large <- abs(lfcList[[x]]$log2FoldChange) > mLog[2]

    # Extract total normalized counts
    norm.counts <- counts(ddsList[[x]], normalized=T)

    # Save filtered genes only from the normalized count data
    heatmap.df.List[[x]] <- norm.counts[is.fdr.valid & is.lfc.large,]

}

# Explore the cleaned data frames 
head(heatmap.df.List[[1]])
head(heatmap.df.List[[2]])

dim(heatmap.df.List[[1]])
dim(heatmap.df.List[[2]])


for (x in Aligners) {

    # Assign the input data frame
    df <- heatmap.df.List[[x]]

    # Print the heatmap
    print(pheatmap(df,
                   annotation=HeatmapAnno, 
                   scale="row",
                   show_rownames=F,
                   main=paste("Expression Profiling by", 
                              x, 
                              paste0("(FDR < ", 
                                     alpha,
                                     ", absolute log2FoldChange > ",
                                     mLog[1]))))

}


```



## NA statistics: zero count genes & outlier genes

#### When NAs appear in  

#### - **log2FoldChange**: zero counts in all samples

#### - **padj**: too little information 

#### - **pval & padj**: at least one replicate was an outlier 

```{r NA_genes}

# Count number of NA genes  
type=c("Zero Counts", "Outliers", "Total NA Genes") 

# Create a data frame storing number of NA genes by type
NA.genes <- lfc.dataframe %>% 
    group_by(Alignment) %>% 
    summarize(zero=sum(is.na(log2FoldChange)), 
              outlier=sum(is.na(pvalue) & is.na(padj))) %>% 
    mutate(total=zero + outlier) %>%
    gather(Type, Number, -Alignment) %>% 
    mutate(Type=factor(case_when(Type == "zero" ~ type[1],
                                 Type == "outlier" ~ type[2],
                                 Type == "total" ~ type[3]),
                       levels=type))

# Plot number of NA genes 
ggplot(NA.genes, 
       aes(x=Type, y=Number, group=Alignment, fill=Alignment, label=Number)) + 
    geom_bar(stat="identity", position="dodge") + 
    theme_bw() +
    geom_text(position=position_dodge(width=1), vjust=1.5) + 
    ggtitle("Number of NA Genes") + 
    ylab("Number of Genes")


```

## baseMean/LFC/FDR comparison between aligners 




```{r diff_prep}



# Create a data frame storing the number of transcripts by gene id
AnnoDb.ntrans <- AnnoDb %>% 
    group_by(GENEID) %>% 
    summarize(Alternative.Transcripts=n_distinct(TXID))

# Create an empty list storing significant gene lfc tables 
sigList <- list() 


# Filter significant genes' lfc and save in the list 
for (x in Aligners) {


    sigList[[x]] <- subset(lfcList[[x]], FDR == paste("<", alpha))

}

# Create a vector storing column names
c_names <- colnames(sigList[[1]])[-1] 
c_names <- c("GENEID", 
             paste0(c_names, "_", Aligners[1]), 
             paste0(c_names, "_", Aligners[2]))


# Join tables by GENEID
lfcTable <- sigList[[1]] %>% 
    inner_join(sigList[[2]], by="GENEID") 

# Rename the columns
names(lfcTable) <- c_names





# Calculate differences
lfcTable <- lfcTable %>%

    mutate(mean_ST_HI=baseMean_STAR - baseMean_HISAT2, 
           lfc_ST_HI=log2FoldChange_STAR - log2FoldChange_HISAT2,
           FDR_ST_HI=padj_STAR - padj_HISAT2) %>% 
            left_join(AnnoDb.ntrans, by="GENEID")




# Explore the output table
head(lfcTable)
dim(lfcTable)

```

## Relationship between baseMean/log2FoldChange/padj with the number of alternative transcripts 

#### - Variables of interest: baseMean, log2FoldChange, and padj 

#### - R-squared: tests whether the two variables are correlated




```{r comparison, fig_width=12}


my.param <- c("baseMean", "log2FoldChange", "padj")


# Slice and clean the data frame for input
lfcTable.comp <- lfcTable %>% 
    dplyr::select(GENEID, Alternative.Transcripts, starts_with(my.param)) %>% 
    gather(Category, Value, -GENEID, -Alternative.Transcripts) %>% 
    separate(Category, c("Metric", "Aligner"), sep="_") %>% pivot_wider(names_from=Aligner, values_from=Value) %>% 
    group_by(Metric) %>%
    nest() %>% 

    # Calculate correlation coefficients between aligners by metric
    mutate(star.hisat.corr=map_dbl(data, ~ cor(.x$STAR, .x$HISAT2)),
           data=map2(data, 
                     star.hisat.corr,
                     ~ mutate(.x, Rsquared=c(.y, rep("", nrow(.x)-1))))) %>%

    # Unnest
    unnest(data) 

# Explore the cleaned data frame
head(lfcTable.comp)


# Create scatter plots comparing HISAT2 and STAR alignment results
ggplot(lfcTable.comp,
       aes(x=HISAT2, 
           y=STAR, 
           color=log(Alternative.Transcripts), 
           label=Rsquared)) + 
geom_point(alpha=0.5) + 
theme_bw() + 
facet_wrap(~ Metric, scales="free") + 
theme(strip.text.x=element_text(size=10)) +
geom_text(size=4, 
          mapping=aes(x=Inf, y=Inf), 
          vjust=2, hjust=1.1, color="black") +
geom_abline(slope=1, size=0.5, linetype="dashed", color="black") + 
ggtitle("HISAT2 vs STAR comparison (with R-Squared)") + scale_color_gradient(low="blue", high="red") 

```


## Distribution of baseMean/log2FoldChange/padj between HISAT2 and STAR 

#### - P-Values: determines whether distribution of the values is different with statistical significance using Two-tailed t-test



```{r distribution, fig.height=12, fig.width=12}


# Clean the data frame 
lfcTable.rel <- lfcTable %>%
    dplyr::select(starts_with(c(my.param, "GENEID"))) %>% 
    gather(Key, Value, -GENEID) %>% 
    separate(Key, c("Metric", "Aligner"), sep="_") %>% 
    group_by(Metric) %>%
    nest() %>%
    mutate(ttest=map_dbl(data, ~ t.test(.x$Value ~ .x$Aligner, data=.x)$p.value),
           data=map2(data, 
                     ttest, 
                     ~ mutate(.x, Pval=c(.y, rep("", nrow(.x)-1))))) %>% 
    unnest(data) %>%
    mutate(Log.Value=log(Value)) %>% 
    gather(Transformation, Value, Value, Log.Value) %>% 
    mutate(Transformation=ifelse(Transformation == "Value",
                                 "Original", 
                                 "Log-Transformed"),
           Transformation=factor(Transformation, 
                                 levels=c("Original", "Log-Transformed")))

# Create boxplots presenting the distribution    
ggplot(lfcTable.rel,
       aes(x=Aligner,
           y=Value, 
           label=Pval)) +
geom_jitter(alpha=0.5, aes(color=Aligner)) + 
geom_boxplot(data=lfcTable.rel, 
             alpha=0.5, outlier.alpha=0, aes(x=Aligner, y=Value)) + 
theme_bw() + 
facet_wrap(Transformation ~ Metric, scales="free") + 
xlab("Aligner") + 
ylab("Value") +
geom_text(size=5, mapping=aes(x=Inf, y=Inf), vjust=2, hjust=1.2) + 
theme(strip.text.x=element_text(size=10)) + 
ggtitle("Distribution Comparison (with P-Value from Two-Tailed T-Test)") 






```


## Exploring relationship between absolute difference/percent difference vs the number of alternative transcripts 

#### - Absolute Difference: HISAT2 - STAR

#### - Percent Difference: 100 x (abs(HISAT2 - STAR) / HISAT2 + STAR)


```{r percent_difference, fig.width=12}

# Add columns storing percent difference
lfcTable <- lfcTable %>%

    # mDiff: difference in meanBase
    # lDiff: difference in log2FoldChange
    # fDiff: difference in padj (FDR)
    mutate(mDiff_percent=100 * mean_ST_HI / (baseMean_STAR + baseMean_HISAT2),
           lDiff_percent=100 * lfc_ST_HI / 
               (abs(log2FoldChange_STAR) + abs(log2FoldChange_HISAT2)),
           fDiff_percent=100 * FDR_ST_HI / (padj_STAR + padj_HISAT2))

# Explore the output
head(lfcTable)
dim(lfcTable)

# Create an empty data frame
lfcTable.percent <- data.frame()


for (x in my.param) {

    
    init.vec <- c("GENEID", "Alternative.Transcripts")

    # Set columns of interest
    if (x == my.param[1]) { 

        col.of.interest <- c(init.vec, "mean_ST_HI", "mDiff_percent")

    } else if (x == my.param[2]) {

        col.of.interest <- c(init.vec, "lfc_ST_HI", "lDiff_percent")

    } else {

        col.of.interest <- c(init.vec, "FDR_ST_HI", "fDiff_percent") 

    }



    # Trim the table 
    df <- lfcTable[, colnames(lfcTable) %in% col.of.interest] %>%
        mutate(Metric=x) %>%
        dplyr::rename(Absolute.Difference=ends_with("HI"), 
                      Percent.Difference=ends_with("percent"))    

    # Save in the empty data frame 
    if (x == my.param[1]) {

        lfcTable.percent <- df

    } else {

        lfcTable.percent <- rbind(lfcTable.percent, df)

    }


}

# Explore the output
head(lfcTable.percent)
dim(lfcTable.percent)


# Nest the data frame by Metric
lfcTable.percent <- lfcTable.percent %>%
    group_by(Metric) %>%
    nest()

# Explore the output
lfcTable.percent
head(lfcTable.percent$data[[1]])


# Calculate correlation (Rsquared) 
# DvsP: Percent Difference vs Difference
lfcTable.percent <- lfcTable.percent %>%
    mutate(Mod=map(data, ~ lm(Percent.Difference ~ Absolute.Difference, data=.x)),
           rsq=map_dbl(Mod, ~ summary(.x)$r.squared),
           data=map2(data, 
                     rsq, 
                     ~ mutate(.x, 
                                Rsquared=c(.y, rep("", nrow(.x)-1))))) %>%

    unnest(data)



# Explore the output data frame
head(lfcTable.percent)

# Print the plots
ggplot(lfcTable.percent, 
       aes(x=abs(Absolute.Difference),
           y=abs(Percent.Difference),
           color=log(Alternative.Transcripts),
           label=Rsquared)) + 
    geom_point(alpha=0.5) + 
    theme_bw() + 
    scale_color_gradient(low="blue", high="red") + 
    facet_wrap(~Metric, scales = "free") + 
    theme(strip.text.x=element_text(size=10)) + 
    geom_text(size=5, 
              aes(x=Inf, y=Inf), 
              vjust=2, hjust=1.1, color="black") +
    ggtitle("Discordance between HISAT2 and STAR") + 
    xlab("Absolute Difference\n(HISAT2 - STAR)") + 
    ylab("Percent Difference\n(100 x (HISAT2 - STAR) / (HISAT2 + STAR))")




```


## Comparison of Ranking between HISAT2 and STAR in baseMean/log2FoldChange/FDR



```{r ranking_comparison_prep}

# Set a function rearranging a data frame
rank.fn <- function(df, var, desc=F) { 
    
    if (desc) { 

        df <- dplyr::arrange(df, desc(var)) 

    } else {

        df <- dplyr::arrange(df, var) 

    }


    return(df)

}


# Set a function creating a rank plot
rank.plot.fn <- function(df, metric, colog=F) { 


    if (colog) { 

        p <- ggplot(df, aes(x=Rank.x, 
                            y=Rank.y, 
                            color=log(MeanValue), 
                            label=Rsquared))

    } else {

        p <- ggplot(df, aes(x=Rank.x, 
                            y=Rank.y, 
                            color=MeanValue,
                            label=Rsquared))

    }
    
    p <- p + 
        geom_point(alpha=0.5) + 
        theme_bw() + 
        scale_color_gradient(low="blue", high="red") + 
        xlab("Rank in HISAT2") + 
        ylab("Rank in STAR") + 
        ggtitle(paste("Rank Comparison in", metric, "\n(with R-Squared)")) + geom_text(size=5, 
                mapping=aes(x=Inf, y=Inf), vjust=2, hjust=1, color="black") +
        geom_abline(slope=1, size=0.5, linetype="dashed", color="black")  

    return(p)

}


```


```{r ranking_comparison, fig.width=12}



# Clean the data frame 
lfcTable.rank <- lfcTable %>% 

    # Splice by columns of interest
    dplyr::select(GENEID, 
                  starts_with(c("baseMean_", "log2FoldChange_", "padj_"))) %>% 

    # Reform the table
    gather(Metric, Value, -GENEID) %>%

    # Nest by Metric
    group_by(Metric) %>%
    nest() %>% 

    # Add columns storing ascending or descending order by variable of interest
    mutate(Ascending=map(data, ~ rank.fn(.x, .x$Value)), 
           Descending=map(data, ~ rank.fn(.x, .x$Value, T)),
           Final=map2(Ascending, 
                      Descending, 
                      ~ ifelse(Metric %in% c("padj_HISAT2", "padj_STAR"),
                               Ascending, 
                               Descending)), 
           Final=map(Final, ~ .x[[1]]),

           # Add a column storing rank
   Final=map(Final, ~ mutate(.x, Rank=1:nrow(.x)))) %>%

    # Unnest 
    unnest(Final) %>% 

    # Reform the table 
    separate(Metric, c("Metric", "Aligner")) %>% 
    dplyr::select(-data, -Ascending, -Descending) %>%

    # Renest by metric
    group_by(Metric) %>%
    nest() %>%

    # Reclean the data frame 
    mutate(Split=map(data, ~ split(.x, .x$Aligner)),
           Joined=map(Split, ~ inner_join(.x[[1]], 
                                          .x[[2]], 
                                          by=c("GENEID")))) %>%
    dplyr::select(-data, -Split) %>%

    # Unnest
    unnest(Joined) %>%

    # Calculate and save MeanRank and MeanValue
    mutate(MeanRank=(Rank.x + Rank.y)/2, 
           MeanValue=abs((Value.x + Value.y)/2)) %>% 

    # Nest by Metric
    nest(-Metric) %>%

    # Add a column storing R^2
    mutate(rsq=map_dbl(data, ~ cor(.x$Rank.x, .x$Rank.y)),
           data=map2(data, 
                     rsq, 
                     ~ mutate(.x, 
                              Rsquared=c(.y, 
                                         rep("", nrow(.x)-1))))) %>%


    # Add columns storing scatter plots
    mutate(RankPlot=map(data, ~ rank.plot.fn(.x, Metric)), 
           RankPlot.log=map(data, ~ rank.plot.fn(.x, Metric, T)))


# Explore the data frame 
head(lfcTable.rank)
head(lfcTable.rank$data[[2]])



# Explore the plots
for (i in 1:3) {

    print(grid.arrange(lfcTable.rank$RankPlot[[i]],
                       lfcTable.rank$RankPlot.log[[i]], nrow=1))


}




# Complete the optimal presentation for the plots
grid.arrange(lfcTable.rank$RankPlot.log[[1]], 
             lfcTable.rank$RankPlot.log[[2]], 
             lfcTable.rank$RankPlot[[3]], nrow=1) 


```





## Saving difference tables 


```{r saving_diff_csv}

# Create an empty data frame for storing cleaned discordance table
lfcTable.discordance <- data.frame()


for (x in my.param) {

    # Subset by metric
    df <- subset(lfcTable.percent, Metric == x)[, 1:5]


    # Rearrange the data frame using the function rank.fn() set previously
    df <- rank.fn(df, abs(df$Percent.Difference), desc=T) 

    # Save the output in the lfcTable.discordance data frame by rbinding
    lfcTable.discordance <- rbind(lfcTable.discordance, 
                                  df)

    # Print the output data frame
    print(head(df)) 


    # Save as a csv file
    write.csv(df, 
              paste0(x, "_difference.csv"))

    


}


# Explore the output data frame
head(lfcTable.discordance)
dim(lfcTable.discordance)
glimpse(lfcTable.discordance)

# Assign a new vector storing discordance group
discordance.group <- c(rep("High % Difference", num.dis.genes), 
                       rep("Low % Difference", num.dis.genes))

# Clean the data frame keeping only 100 top- and 100 bottom-percent difference genes 
lfcTable.discordance <- lfcTable.discordance %>%
    group_by(Metric) %>%
    nest() %>%
    mutate(Sampled=map(data, ~ rbind(head(.x, num.dis.genes), tail(.x, num.dis.genes))),
           Sampled=map(Sampled, ~ mutate(.x, Discordance=discordance.group))) %>%
    dplyr::select(-data) %>%
    unnest(Sampled)


# Explore the output data frame
head(lfcTable.discordance)
dim(lfcTable.discordance)
glimpse(lfcTable.discordance)
```


## Comparing the number of repetitive elements


#### - Tandem Repeats Finder (TRF): [Web](https://tandem.bu.edu/trf/trf.html), [Linux Version](https://tandem.bu.edu/trf/trf.unix.help.html), [Reference paper](https://pubmed.ncbi.nlm.nih.gov/9862982)


#### - Genomic sequences were retrieved by using the Ensembl  REST API [GET sequence/id/:id](https://rest.ensembl.org/documentation/info/sequence_id), [GET archive/id/:id](https://rest.ensembl.org/documentation/info/archive_id_get)

```{r count_repetitive_elements}

# Create a vector storing unique GENEID
geneid <- unique(lfcTable.discordance$GENEID)


# Assign the server for API 
server <- "https://rest.ensembl.org"


for (i in 1:length(geneid)) {

    # Test whether the gene id is currently in the database
    ext.id <- paste0("/archive/id/", geneid[i], "?")

    r.id <- GET(paste(server, ext.id, sep = ""), 
                content_type("application/json"))

    stop_for_status(r.id)

    # If the gene id is currently in the database
    if (content(r.id)$is_current == "1") {

        # Retrieve data using ensembl gene ids 
        ext.seq <- paste0("/sequence/id/",
                      geneid[i],
                      "?")

        r.seq <- GET(paste(server, ext.seq, sep = ""), content_type("text/plain"))
         
        stop_for_status(r.seq)

        line1 <- paste0(">", geneid[i]) 
        line2 <- content(r.seq)

        # Save the gene id and sequences as fasta format 
        write(line1, file="trf_input.fa", append=T)
        write(line2, file="trf_input.fa", append=T)
    }

}


# Run tandem repeats finder (trf): only takes fasta format as an input file  
system("trf trf_input.fa 2 7 7 80 10 50 500 -d -h")  # Returns a .dat file 

# Convert the TRF result .dat data to a data frame
trflines <- readLines("trf_input.fa.2.7.7.80.10.50.500.dat")

trfTable <- data.frame()
for (i in 7:length(trflines)) {

    if (trflines[i] != "" & !grepl("Parameters", trflines[i], fixed=T)) {



        trflines[i] <- str_replace(trflines[i], "Sequence: ", "")

        df <- data.frame(Line=trflines[i])

        trfTable <- rbind(trfTable, df)

    }

}


# Clean the TRF data frame
trfTable <- trfTable %>%
    mutate(code=ifelse(grepl(geneid.species, Line, fixed=T), 
                       "ID", 
                       "DNA")) 



# Extract the number of repetitive elements per GENEID
trfnumTable <- data.frame()
code.vector <- trfTable$code

GENE <- c()
COUNT <- c()

index.id <- 0
index.dna <- 0
for (i in 1:nrow(trfTable)) {


    if (code.vector[i] == "ID") {

        index.id <- index.id + 1
        index.dna <- 0

    } else {

        index.id <- 0
        index.dna <- index.dna + 1
    }



    GENE[i] <- index.id # Indicates GENEID coded "ID"
    COUNT[i] <- index.dna  # Indicates repetitive elements coded "DNA" 


}

repetitive.geneid <- which(COUNT == 1) - 1  # right before the first repetitive elements
repetitive.first <- which(COUNT == 1)  # the first repetitive elements 
repetitive.last <- which(GENE == 1) - 1  # the last repetitive elements per GENEID 

# Explore the indices
repetitive.geneid
repetitive.first
repetitive.last


# In case that the first gene had one repetitive element: 
if (repetitive.last[1] < repetitive.first[1]) {

    repetitive.last <- repetitive.last[-1]

    if (repetitive.last[length(repetitive.last)] < 
        repetitive.first[length(repetitive.first)]) {

        repetitive.last <- c(repetitive.last, 
                             repetitive.first[length(repetitive.first)])

    }



}

# Explore the indices
repetitive.geneid
repetitive.first
repetitive.last

# Save the repetitive elements counted as a data frame
trfnumTable <- data.frame(GENEID=trfTable$Line[repetitive.geneid],
                          Repeats_First=repetitive.first, 
                          Repeats_Last=repetitive.last) %>% 
mutate(Repetitive.Elements=Repeats_Last - Repeats_First + 1) %>%
dplyr::select(GENEID, Repetitive.Elements)


# Join the TRF result with the discordance data frame
lfcTable.discordance <- lfcTable.discordance %>%
    left_join(trfnumTable, by="GENEID") %>%
    mutate(Repetitive.Elements=ifelse(is.na(Repetitive.Elements), 
                                      0, 
                                      Repetitive.Elements))


# Remove duplicated rows
lfcTable.discordance <- lfcTable.discordance[!duplicated(lfcTable.discordance),]

# Explore the output data frame
glimpse(lfcTable.discordance)
dim(lfcTable.discordance)
head(lfcTable.discordance)


```


## Comparing the number of variant alleles

#### - The number of variants were retrieved by using the [Ensembl REST API (GET overlap/id/:id)](https://rest.ensembl.org/documentation/info/overlap_id)

#### - Reference: [The Ensembl Variant Effect Predictor (McLaren et al., 2016)](https://pubmed.ncbi.nlm.nih.gov/27268795)



```{r count_variants}


# Create an empty vector storing the number of variant alleles per gene id 
var.df <- data.frame() 

for (i in 1:length(geneid)) {

    # Test whether the gene id is currently in the database
    ext.id <- paste0("/archive/id/", geneid[i], "?")

    r.id <- GET(paste(server, ext.id, sep = ""), 
                content_type("application/json"))

    stop_for_status(r.id)

    # If the gene id is currently in the database
    if (content(r.id)$is_current == "1") {

        # Retrieve data using ensembl gene id 
        ext <- paste0("/overlap/id/",
                      geneid[i],
                      "?feature=variation")

        r <- GET(paste(server, ext, sep = ""), content_type("application/json"))
         
        stop_for_status(r)

        # Extract the variant ids 
        df <- data.frame(t(sapply(content(r),c))) %>% 
            gather("Variable", "Value") 

        nvar <- 0

        # If no variant is found:
        if (ncol(df) != 0) {

            # Save variant ids filtered as a data frame
            df <- df %>% 
                dplyr::filter(str_detect(Value, "rs")) %>% 
                mutate(Value=unlist(Value)) 

            # Create a vector storing unique variant ids
            nvar <- length(unique(df$Value))


        } 

        # Create a data frame storing gene id and corresponding unique variant ids 
        df.nvar <- data.frame(GENEID=geneid[i], 
                              Variant.Alleles=nvar)

        # Combine the data frames
        var.df <- rbind(var.df, df.nvar)

    }



}



# Explore the output data frame
head(var.df)
dim(var.df)
glimpse(var.df)


# Combine the number of variant alleles to the percent discordance table 
lfcTable.discordance <- lfcTable.discordance %>%
    left_join(var.df,
               by="GENEID") %>% 
    mutate(Variant.Alleles=ifelse(is.na(Variant.Alleles), 
                                  0, 
                                  Variant.Alleles))


# Explore the combined data frame
head(lfcTable.discordance)
glimpse(lfcTable.discordance)
dim(lfcTable.discordance)


# Save total discordance table in a csv file
write.csv(lfcTable.discordance, "total_discordance.csv")



```


## Investigating relationship between alignment discordance and the number of alternative transcripts/variant alleles/repetitive elements


```{r clean_plot_data, fig.height=12, fig.width=12}

# Clean the data frame
lfcTable.summary <- lfcTable.discordance %>%
    mutate(Percent.Difference=abs(Percent.Difference), 
           Absolute.Difference=abs(Absolute.Difference))


# Remove duplicated rows 
lfcTable.summary <- lfcTable.summary[!duplicated(lfcTable.summary),]

# Explore the cleaned output data frame
head(lfcTable.summary)
dim(lfcTable.summary)
glimpse(lfcTable.summary)


# Clean and nest the data frame
lfcTable.summary <- lfcTable.summary %>%
    gather(Variable, 
           Value, 
           Percent.Difference,
           Absolute.Difference, 
           Alternative.Transcripts, 
           Repetitive.Elements,
           Variant.Alleles) %>% 
    group_by(Metric, Variable) %>%
    nest() %>%

    # Calculate p-values using two-tailed t-test and clean the data frame
    mutate(ttest=map_dbl(data, ~ t.test(Value ~ Discordance, 
                                    data=.x)$p.value),
           data=map2(data, 
                     ttest,
                     ~ mutate(.x, P.Value=c(.y, rep("", nrow(.x)-1))))) %>%
    unnest(data) %>% 
    group_by(Metric) %>%
    nest()

# Display the difference plot in baseMean, log2FoldChange, and padj
for (i in 1:nrow(lfcTable.summary)) {

    df <- lfcTable.summary$data[[i]]
    metric <- lfcTable.summary$Metric[i]

    df$Variable <- factor(df$Variable,
                          levels=c("Percent.Difference", 
                                   "Absolute.Difference", 
                                   "Alternative.Transcripts", 
                                   "Repetitive.Elements", 
                                   "Variant.Alleles"))

    # without log transformation of y-scale
    p1 <- ggplot(df,
               aes(x=Discordance,
                   y=Value, 
                   label= P.Value)) +
        geom_jitter(alpha=0.5, aes(color=Discordance)) + 
        geom_boxplot(alpha=0.5, outlier.alpha=0) + 
        theme_bw() + 
        facet_wrap(~ Variable, scales="free") + 
        theme(strip.text=element_text(size=11), 
              axis.text=element_text(size=10)) + 
        geom_text(size=5, 
                  mapping=aes(x=Inf, y=Inf), 
                  vjust=2, hjust=1.1, color="black") + 
        ggtitle(paste("Comparison between High vs Low Difference Genes in",
                      metric,
                      "\n(with P-Values from Two-Tailed T-Test)"))

    # with log transformation of y-scale
    p2 <- p1 + 
        scale_y_log10() + 
        ggtitle(paste("Comparison between High vs Low Difference Genes in",
                      metric,
                      "\n(with P-Values from Two-Tailed T-Test and Log-Transformed Y-Scale)"))

    print(p1)
    print(p2)



}





```


## Summarizing up/down-regulated DEGs using an upset plot

#### - The upset plot is designed to display intersecting DEG sets  

#### - References: [Lex et al., 2014](https://ieeexplore.ieee.org/document/6876017), [Conway et al., 2017](https://academic.oup.com/bioinformatics/article/33/18/2938/3884387), [GitHub](https://github.com/hms-dbmi/UpSetR)

```{r upset_plot, fig.height=10, fig.width=12}

# Generate a data frame storing upset input variables
upset.dataframe <- subset(lfc.dataframe, !is.na(padj)) %>%
    
    mutate(Up=ifelse(FDR == paste("<", alpha) & log2FoldChange > 0, GENEID, ""), 
           Down=ifelse(FDR == paste("<", alpha) & log2FoldChange < 0, GENEID, ""),
           Unchanged=ifelse(FDR == paste(">", alpha), GENEID, ""),
           STAR=ifelse(Alignment == "STAR", GENEID, ""),
           HISAT2=ifelse(Alignment == "HISAT2", GENEID, ""))

# Generate a list input 
upset.input <- list(Up=upset.dataframe$Up, 
                    Down=upset.dataframe$Down,
                    Unchanged=upset.dataframe$Unchanged, 
                    HISAT2=upset.dataframe$HISAT2,
                    STAR=upset.dataframe$STAR)

# Create an upset plot
upset(fromList(upset.input), 
      sets=names(upset.input),   # What group to display 
      sets.x.label="Number of Genes per Intersection",
      order.by="freq",
      point.size=3,
      keep.order=T,
      sets.bar.color=c("red", "red", "red", "blue", "blue"),
      text.scale = 1.5, number.angles=30)





      
```

## Session Info

```{r session_info}

sessionInfo()

```

